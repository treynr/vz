/**
 * file: bar.js
 * desc: d3js 4.0 implementation of bar charts.
 * vers: 0.1.0
 * auth: TR
 */

/*
 * The data structure necessary for this viz is an array of objects, each of
 * which contains the following fields:
 *      x:  [REQUIRED], a discrete value representing the class or type of this
 *          object. This label is plotted on the x-axis.
 *
 *      y:  [REQUIRED], the numeric value associated with label x. Plotted on
 *          the y-axis.
 *
 *      group:  [OPTIONAL], a group label the data point belongs to. This is
 *              used to generate grouped bar charts.
 *
 * If x is not a discrete object, but some other numeric, continuous value, the
 * user can choose to bin the values together to produce a sort of histogram.
 *
 */
var bar = function() {

    var exports = {},
        data = null,
        svg = null,
        // SVG width
        width = 800,
        // SVG height
        height = 500,
        // Margin object
        margin = {top: 10, right: 30, bottom: 30, left: 30},
        // Bar chart color
        barColor = '#98ABC5',
        // Bar chart edge color
        barStroke = '#222222',
        // Boolean to draw or hide the outer x-axis ticks
        outerTicks = false,
        // Width of each bar in the chart
        barWidth = null,
        // Use a grouped bar chart style
        grouped = null,
        // List of data groups
        groups = null,
        // Generate the chart as a histogram
        asHistogram = false,
        // The number of bins to use
        numBins = 15,
        // An array containing custom binning values to use
        customBins = [],
        // Scale for the x-axis
        xScale = null,
        // Grouped chart scale for the x-axis
        xGroupScale = null,
        // Histogram scale for the x-axis
        xHistoScale = null,
        // Scale for the y-axis
        yScale = null,
        // Bar chart object
        chart = null,
        // Binned data generated by the histogram
        bins = null
        ;

    /** private **/

    var getWidth = function() { return width - margin.left - margin.right; };
    var getHeight = function() { return height - margin.top - margin.bottom; };

    var makeScales = function() {

        var xdomain = data.map(function(d) { return d.x; });
        var ydomain = [0, d3.max(data, function(d) { return d.y; })];


        if (grouped) {

            xGroupScale = d3.scaleBand()
                .domain(returnKeyUniques('x'))
                .rangeRound([margin.left, getWidth()])
                .paddingInner(0.1);

            xScale = d3.scaleBand()
                .domain(returnKeyUniques('group'))
                .range([0, xGroupScale.bandwidth()])
                .padding(0.05);

        } else {

            xScale = d3.scaleBand()
                .domain(xdomain)
                .range([margin.left, getWidth()])
                .padding(0.2);
        }

        if (asHistogram) {


            var histData = [];

            for (var i = 0; i < data.length; i++) {
                for (var j = 0; j < data[i].y; j++) {

                    histData.push(data[i].x);
                }
            }

            //xScale = d3.scaleQuantize()
            //xHistoScale = d3.scaleQuantize()
            xHistoScale = d3.scaleLinear()
                .domain([d3.min(histData), d3.max(histData)])
                .range([margin.left, getWidth()])
                //.padding(0.2)
                ;

            bins = d3.histogram()
                .domain(xHistoScale.domain())
                //.domain(xScale.domain())
                .thresholds(function() { 
                    if (customBins && customBins.length !== 0)
                        return customBins;
                    else
                        return xHistoScale.ticks(numBins);
                    //return xHistoScale.ticks(numBins);
                })
                //.thresholds(
                //(data)
                (histData)
                ;

            console.log('bins');
            console.log(bins);
            xScale = d3.scaleBand()
                .domain(bins.map(function(d) { return d.x1; }))
                .rangeRound([margin.left, getWidth()])
                .paddingInner(0.1)
                ;

            yScale = d3.scaleLinear()
                .domain([0, d3.max(bins, function(d) { return d.length; })])
                .range([getHeight(), 0]);

            return;
        }

        yScale = d3.scaleLinear()
            .domain(ydomain)
            .range([getHeight(), 0]);
    };

    var makeAxes = function() {

        if (grouped)
            xAxis = d3.axisBottom(xGroupScale).tickSizeOuter(outerTicks ? 6 : 0);
        else
            xAxis = d3.axisBottom(xScale).tickSizeOuter(outerTicks ? 6 : 0);

        yAxis = d3.axisLeft(yScale);

        svg.append('g')
            .attr('class', 'axis')
            .attr('transform', function() {
                return 'translate(0' + ',' + (getHeight() + 1) + ')';
            })
            .style('font', '11px sans-serif')
            .style('font-weight', 'normal')
            .style('fill', 'none')
            .call(xAxis)
            ;

        svg.append('g')
            .attr('class', 'axis axis--x')
            .style('font', '11px sans-serif')
            .style('font-weight', 'normal')
            .style('fill', 'none')
            .call(yAxis)
            ;
    };

    var makeCustomBins = function() {

        var b = [];

        for (var i = 2; i <= 12; i++)
            //console.log(i + ', ' + Math.pow(i, 2));
            b.push(Math.pow(2, i));

        return b;
    };

    var checkGrouped = function() {

        if (data[0]['group'] === undefined)
            return false;

        return true;
    };

    var returnKeyUniques = function(key) {
        var unique = {};

        for (var i = 0; i < data.length; i++)
            unique[data[i][key]] = 0;

        return Object.keys(unique);
    };

    var drawBars = function() {

        var bar = svg.selectAll('.bar')
            .data(function() { 
                if (asHistogram) 
                    return bins;
                else
                    return data;
            })
            .enter()
            .append('g')
            .attr('class', 'bar')
            .attr('transform', function(d) { 
                if (grouped)
                    return 'translate(' + xGroupScale(d.x) + ',0)'; 
                else
                    return 'translate(0,0)'; 
            })
            ;

        if (!grouped) {

            bar.append('rect')
                .attr('x', function(d) { 
                    if (asHistogram)
                        //return xHistoScale(d.x0); 
                        return xScale(d.x1); 
                    else
                        return xScale(d.x); 
                })
                .attr('y', function(d) { 
                    if (asHistogram)
                        return yScale(d.length);
                    else
                        return yScale(d.y); 
                })
                .attr('width', function(d) { 
                    return xScale.bandwidth();
                })
                .attr('height', function(d) { 
                    if (asHistogram)
                        return getHeight() - yScale(d.length); 
                    else
                        return getHeight() - yScale(d.y); 
                })
                .style('shape-rendering', 'auto')
                .style('fill', barColor)
                .style('stroke', barStroke)
                .style('stroke-width', '1px')
                ;

        } else {
        var z = d3.scaleOrdinal()
            .range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);
            bar.append('rect')
                .attr('x', function(d) { return xScale(d.group); })
                .attr('y', function(d) { return yScale(d.y); })
                .attr('width', function(d) { 
                    return xScale.bandwidth();
                })
                .attr('height', function(d) { 
                    return getHeight() - yScale(d.y); 
                })
                .style('shape-rendering', 'auto')
                .style('fill', function(d) { return z(d.group); })
                .style('stroke', barStroke)
                .style('stroke-width', '1px')
                ;
        }

    };

    /** public **/

    exports.draw = function() {

        svg = d3.select('body')
            .append('svg')
            .attr('height', height)
            .attr('width', width)
            .append('g')
            .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
            ;

        grouped = checkGrouped();

        makeScales();

        if (grouped) {
            groups = returnKeyUniques('group');
        }

        makeAxes();
        drawBars();
    };

    /** setters/getters **/

    exports.data = function(_) {
        if (!arguments.length) return data;
        data = _;
        return exports;
    };

    exports.width = function(_) {
        if (!arguments.length) return width;
        width = +_;
        return exports;
    };

    exports.height = function(_) {
        if (!arguments.length) return height;
        height = +_;
        return exports;
    };

    exports.barStroke = function(_) {
        if (!arguments.length) return barStroke;
        barStroke = +_;
        return exports;
    };

    exports.barColor = function(_) {
        if (!arguments.length) return barColor;
        barColor = _;
        return exports;
    };

    exports.barWidth = function(_) {
        if (!arguments.length) return barWidth;
        barWidth = +_;
        return exports;
    };

    exports.outerTicks = function(_) {
        if (!arguments.length) return outerTicks;
        outerTicks = _;
        return exports;
    };

    exports.grouped = function(_) {
        if (!arguments.length) return grouped;
        grouped = _;
        return exports;
    };

    exports.numBins = function(_) {
        if (!arguments.length) return numBins;
        numBins = +_;
        return exports;
    };

    exports.asHistogram = function(_) {
        if (!arguments.length) return asHistogram;
        asHistogram = _;
        return exports;
    };

    exports.customBins = function(_) {
        if (!arguments.length) return customBins;
        customBins = _;
        return exports;
    };

    return exports;
};

var legend = function(data, opts) {

    opts = validateLegendOptions(opts);

    var legend = d3.select('body').append('svg')
        .attr('width', opts.width)
        .attr('height', opts.height)
        .selectAll('g')
        .data(data)
        .enter().append('g')
        .attr("transform", function(d, i) { 
            return "translate(40," + (i + 1) * opts.keyPadding + ")"; 
        });

    legend.append('rect')
        .attr('width', opts.keyWidth)
        .attr('height', opts.keyHeight)
		.attr('stroke', opts.stroke)
		.attr('stroke-width', opts.strokeWidth)
        .attr('shape-rendering', 'crispEdges')
        .style('fill-opacity', opts.opacity)
        .style('fill', function(d, i) {
            if (d.color === undefined)
                return opts.colors[i];

            return d.color;
        });

    legend.append("text")
        .attr("x", opts.textX)
        .attr("y", opts.textY)
        .attr("dy", ".35em")
        .attr('font-family', opts.font)
        .attr('font-size', opts.fontSize)
        .attr('font-weight', opts.fontWeight)
        .text(function(d) { 
			return d.name;
        });
};

/**
 *      height: int, the height of the SVG in pixels
 *      width: int, the width of the SVG in pixels
 *      keyHeight: int, the height of the color box in pixels
 *      keyWidth: int, the width of the color box in pixels
 *      keyPadding: int, padding between color boxes
 *      title: string, legend title
 *      colors: an array of color strings, ensure this is the same size as the
 *          number of data points.
 *      margin: an object of margin values
 *      opacity: float, the opacity of the fill colors
 *      stroke: string, color used to outline the visualization
 *      strokeWidth: string, size in pixels of the stroke outline
 *      font: string, font to use for the legend text
 *      fontSize: string, font size in pixels
 *      fontWeight: string, font weight
 *      textX: int, x coordinate position of each key/color box text
 *      textY: int, y coordinate position of each key/color box text
 */
var validateLegendOptions = function(opts) {

    opts.height = opts.height || 500;
    opts.width = opts.width || 800;
    opts.keyHeight = opts.keyHeight || 20;
    opts.keyWidth = opts.keyWidth || 20;
    opts.keyPadding = opts.keyPadding || 30;
    opts.title = opts.title || '';
    opts.margin = (opts.margin === undefined) ? {} : opts.margin;

    opts.margin.top = opts.margin.top || 10;
    opts.margin.bottom = opts.margin.bottom || 30;
    opts.margin.right = opts.margin.right || 30;
    opts.margin.left = opts.margin.left || 30;

    // These are all the visualization styling options and heavily dependent on
    // the visualization type
    opts.colors = (opts.colors === undefined) ? d3.schemeSet3 : opts.colors;
    opts.opacity = opts.opacity || 1.0;
    opts.stroke = (opts.stroke === undefined) ? '#000' : opts.stroke;
    opts.strokeWidth = (opts.strokeWidth === undefined) ? '1px' : 
                       opts.strokeWidth;
    opts.font = opts.font || 'sans-serif';
    opts.fontSize = opts.fontSize || '15px';
    opts.fontWeight = opts.fontWeight || 'normal';
    opts.textX = opts.textX || (opts.keyWidth + 2);
    opts.textY = opts.textY || (opts.keyHeight / 2 - 2);

    return opts;
};

