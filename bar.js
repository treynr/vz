/**
 * file: bar.js
 * desc: d3js 4.0 implementation of bar charts.
 * vers: 0.1.0
 * auth: TR
 */

/*
 * The data structure necessary for this viz is an array of objects, each of
 * which contains the following fields:
 *      x:  [REQUIRED], a discrete value representing the class or type of this
 *          object. This label is plotted on the x-axis.
 *
 *      y:  [REQUIRED], the numeric value associated with label x. Plotted on
 *          the y-axis.
 *
 *      group:  [OPTIONAL], a group label the data point belongs to. This is
 *              used to generate grouped bar charts.
 *
 * If x is not a discrete object, but some other numeric, continuous value, the
 * user can choose to bin the values together to produce a sort of histogram.
 * I say sort of because this doesn't completely use d3's histogram function.
 *
 */
var bar = function() {

    var exports = {},
        data = null,
        svg = null,
        svgLabel = '',
        // Top level bar chart title
        title = '',
        // SVG width
        width = 800,
        // SVG height
        height = 500,
        // Margin object
        margin = {top: 40, right: 30, bottom: 50, left: 50},
        // Bar chart color
        barColor = '#98ABC5',
        // Bar chart edge color
        barStroke = '#222222',
        // Boolean to draw or hide the outer x-axis ticks
        outerTicks = false,
        // Width of each bar in the chart
        barWidth = null,
        // Use a grouped bar chart style
        grouped = null,
        // List of data groups
        groups = null,
        // List of group bar colors
        groupColors = null,
        // Generate the chart as a histogram
        asHistogram = false,
        // The number of bins to use
        numBins = 15,
        // An array containing custom binning values to use
        customBins = [],
        // Drops the last bin which is sometimes auto generated by d3
        dropLastBin = false,
        // Calculate histogram y-axis values as percentages
        binPercent = false,
        // Overlay chart with normalized distribution
        distribution = false,
        // Axis text size
        fontSize = '11px',
        // X-axis text
        xText = '',
        // Y-axis text
        yText = ''
        // Y-axis padding
        yAxisPad = 35,
        // Padding between bars
        innerPadding = 0.1,
        // Scale for the x-axis
        xScale = null,
        // Grouped chart scale for the x-axis
        xGroupScale = null,
        // Histogram scale for the x-axis
        xHistoScale = null,
        // Scale for the y-axis
        yScale = null,
        // Format string for y-axis labels
        yFormat = '',
        // Y-axis tick values
        yTickValues = null,
        // Y-axis tick values
        yDomain = null,
        // Bar chart object
        chart = null,
        textures = [],
        // Binned data generated by the histogram
        bins = null
        ;

    /** private **/

    var getWidth = function() { return width - margin.left - margin.right; };
    var getHeight = function() { return height - margin.top - margin.bottom; };

    var makeScales = function() {

        var xdomain = data.map(function(d) { return d.x; });
        var ydomain = yDomain ? yDomain : [0, d3.max(data, function(d) { return d.y; })];


        if (grouped) {

            xGroupScale = d3.scaleBand()
                .domain(returnKeyUniques('x'))
                .rangeRound([margin.left, getWidth()])
                .paddingInner(0.1);

            xScale = d3.scaleBand()
                .domain(returnKeyUniques('group'))
                .range([0, xGroupScale.bandwidth()])
                .padding(0.20);

        } else {

            xScale = d3.scaleBand()
                .domain(xdomain)
                .range([margin.left, getWidth()])
                .padding(0.2);
        }

        if (asHistogram) {


            var histData = [];

            for (var i = 0; i < data.length; i++) {
                for (var j = 0; j < data[i].y; j++) {

                    histData.push(data[i].x);
                }
            }

            //xScale = d3.scaleQuantize()
            //xHistoScale = d3.scaleQuantize()
            xHistoScale = d3.scaleLinear()
                .domain([d3.min(histData), d3.max(histData)])
                .range([margin.left, getWidth()])
                //.padding(0.2)
                ;

            bins = d3.histogram()
                .domain(xHistoScale.domain())
                //.domain(xScale.domain())
                .thresholds(function() { 
                    if (customBins && customBins.length !== 0)
                        return customBins;
                    else
                        return xHistoScale.ticks(numBins);
                    //return xHistoScale.ticks(numBins);
                })
                //.thresholds(
                //(data)
                (histData)
                ;

            if (dropLastBin)
                bins = bins.slice(0, bins.length - 1);

            xScale = d3.scaleBand()
                .domain(bins.map(function(d) { return d.x1; }))
                .rangeRound([margin.left, getWidth()])
                .paddingInner(0.1)
                ;

            if (binPercent) {

                binPercent = bins.map(function(d) { return d.length; })
                    .reduce(function(a, b) { return a + b; });
            }

            yScale = d3.scaleLinear()
                .domain([0, d3.max(bins, function(d) { 
                    if (binPercent)
                        return d.length / binPercent; 
                    else
                        return d.length; 
                })])
                .range([getHeight(), 0]);

            return;
        }

        yScale = d3.scaleLinear()
            .domain(ydomain)
            .range([getHeight(), 0]);
    };

    var makeAxes = function() {

        if (grouped)
            xAxis = d3.axisBottom(xGroupScale).tickSizeOuter(outerTicks ? 6 : 0);
        else
            xAxis = d3.axisBottom(xScale).tickSizeOuter(outerTicks ? 6 : 0);

        yAxis = d3.axisLeft(yScale)
            .tickFormat(d3.format(yFormat))
            .tickValues(yTickValues)
            //.tickValues( yScale.ticks(7).concat(parseFloat(yScale.domain()[1]).toFixed(2)) )
            ;
        //console.log(yScale.domain());
        //console.log(yScale.ticks(7));
        //console.log(yScale.ticks(7).concat(parseFloat(yScale.domain()[0])));
        //console.log(typeof(yScale.domain()[1]));
        //console.log( parseFloat(yScale.domain()[1]).toFixed(1) );

        var xAxisObject = svg.append('g')
            .attr('class', 'axis')
            .attr('transform', function() {
                return 'translate(0' + ',' + (getHeight() + 1) + ')';
            })
            //.style('font', '11px sans-serif')
            .style('font-family', 'sans-serif')
            .style('font-size', fontSize)
            //.style('font-weight', opts.fontWeight)
            .style('font-weight', 'normal')
            .style('fill', 'none')
            .call(xAxis)
            .append('text')
            .attr('x', function() { return (margin.left + getWidth()) / 2; })
            .attr('y', 45)
            .attr('fill', '#000')
            .style('text-anchor', 'middle')
            .text(xText)
            ;

        var yAxisObject = svg.append('g')
            .attr('class', 'axis')
            .attr('transform', function() {
                return 'translate(' + yAxisPad + ',0)';
            })
            .style('font-family', 'sans-serif')
            .style('font-size', fontSize)
            .style('font-weight', 'normal')
            .style('fill', 'none')
            .call(yAxis)
            .append('text')
            // Weird x, y argumetnns cause of the -90 rotation
            .attr('x', function() { return -getHeight() / 2; })
            .attr('y', -50)
            .attr('fill', '#000')
            .attr('transform', 'rotate(-90)')
            .style('text-anchor', 'middle')
            .text(yText)
            ;

/*
             svg.append("g")
      .attr("class", "axis axis--y")
      .call(d3.axisLeft(y)
          .ticks(10, "s"))
    .append("text")
      .attr("x", 10)
      .attr("y", 10)
      .attr("dy", ".71em")
      .attr("fill", "#000")
      .attr("font-weight", "bold")
      .attr("text-anchor", "start")
      .text("Price (US$)");

  svg.append("g")
      .attr("class", "axis axis--x")
      .attr("transform", "translate(0," + height + ")")
      .call(d3.axisBottom(x))
    .append("text")
      .attr("x", width - 10)
      .attr("y", -10)
      .attr("dy", "-.35em")
      .attr("fill", "#000")
      .attr("font-weight", "bold")
      .attr("text-anchor", "end")
      .text("Mass (carats)");
*/
        return [xAxisObject, yAxisObject];
    };


    var makeCustomBins = function() {

        var b = [];

        for (var i = 2; i <= 12; i++)
            //console.log(i + ', ' + Math.pow(i, 2));
            b.push(Math.pow(2, i));

        return b;
    };

    var checkGrouped = function() {

        if (data[0]['group'] === undefined)
            return false;

        return true;
    };

    var returnKeyUniques = function(key) {
        var unique = {};

        for (var i = 0; i < data.length; i++)
            unique[data[i][key]] = 0;

        return Object.keys(unique);
    };

    var drawBars = function() {

        var bar = svg.selectAll('.bar')
            .data(function() { 
                if (asHistogram) 
                    return bins;
                else
                    return data;
            })
            .enter()
            .append('g')
            .attr('class', 'bar')
            .attr('transform', function(d) { 
                if (grouped)
                    return 'translate(' + xGroupScale(d.x) + ',0)'; 
                else
                    return 'translate(0,0)'; 
            })
            ;

        if (!grouped) {

            bar.append('rect')
                .attr('x', function(d) { 
                    if (asHistogram)
                        //return xHistoScale(d.x0); 
                        return xScale(d.x1); 
                    else
                        return xScale(d.x); 
                })
                // +1 so the bar converges with the x-axis
                .attr('y', function(d) { 
                    if (asHistogram) {
                        if (binPercent)
                            return yScale(d.length / binPercent) + 1;
                        else
                            return yScale(d.length) + 1;
                    } else { 
                        return yScale(d.y) + 1; 
                    }
                })
                .attr('width', function(d) { 
                    return xScale.bandwidth();
                })
                .attr('height', function(d) { 
                    if (asHistogram) {
                        if (binPercent)
                            return getHeight() - yScale(d.length / binPercent); 
                        else
                            return getHeight() - yScale(d.length); 
                    } else {
                        return getHeight() - yScale(d.y); 
                    }
                })
                .style('shape-rendering', 'auto')
                .style('stroke', '#343434')
                .style('stroke-width', 1)
                .style('fill', function(d) {
                    if (textures.length > 0 && d.texture)
                        return d.texture.url();

                    if (d.color)
                        return d.color;

                    return barColor;
                })
                ;

        } else {
            if (groupColors) {

                var colorScale = d3.scaleOrdinal().range(groupColors);
            } else {

                var colorScale = d3.scaleOrdinal().range([
                    '#98abc5', 
                    '#8a89a6', 
                    '#7b6888', 
                    '#6b486b', 
                    '#a05d56', 
                    '#d0743c', 
                    '#ff8c00'
                ]);
            }

            bar.append('rect')
                .attr('x', function(d) { return xScale(d.group); })
                // +1 so the bar converges with the x-axis
                .attr('y', function(d) { return yScale(d.y) + 1; })
                .attr('width', function(d) { 
                    return xScale.bandwidth();
                })
                .attr('height', function(d) { 
                    return getHeight() - yScale(d.y); 
                })
                .style('shape-rendering', 'auto')
                //.style('stroke', barStroke)
                //.style('stroke-width', '1px')
                .style('stroke', '#343434')
                .style('stroke-width', 1)
                .style('fill', function(d) { 
                    console.log(d);
                    if (textures.length > 0 && d.texture)
                        return d.texture.url();

                    return colorScale(d.group); 
                })
                ;
        }

    };

    var drawText = function() {

    };


    var mean = function(data) {

        return data
            .reduce(function(a, d) { return a + d; }) / data.length;
        //return data
        //    .map(function(d) { return d.y; })
        //    .reduce(function(a, d) { return a + d; }) / data.length;
    };

    var variance = function(data, mean) {

        return data
            .map(function(d) { return Math.pow(d - mean, 2); })
            .reduce(function(a, d) { return a + d; }) / data.length;
        //return data
        //    .map(function(d) { return Math.pow(d.y - mean, 2); })
        //    .reduce(function(a, d) { return a + d; }) / data.length;
    };

    var pdf = function(d, mean, variance, total) {

        //return (1 / Math.sqrt(2 * variance * Math.PI)) * 
        //       Math.exp(-(Math.pow(d - mean, 2) / (2 * variance)));
        return (1 / Math.sqrt(2 * variance * Math.PI)) * 
               Math.exp(-(Math.pow(d - mean, 2) / (2 * variance))) ;//*
               //d * total;
    };

    var drawdist = function() {

        var binVals = bins
            .reduce(function(a, b) { return a.concat(b); }, [])
            .sort(function(a, b) { return a - b; });
        var u = mean(binVals);
        var v = variance(binVals, u);
        var binned = [];
        var probs = [];

        for (var i = 0; i < bins.length; i++) {
            for (var j = 0; j < bins[i].length; j++) {

            }
        }
        var allVals = [];
        var binned = [];

        for (var i = 0; i < bins.length; i++) {
            for (var j = 0; j < bins[i].length; j++) {

                allVals.push(i + 1);
            }
        }
        var u = mean(allVals);
        var v = variance(allVals, u);
        var allProbs = [];

        for (var i = 0; i < bins.length; i++) {
            var probs = 0.0;
            for (var j = 0; j < bins.length; j++) {

                //probs.push(pdf(bins[i][j], u, v));
                //probs += pdf(bins[i][j], u, v);
                probs += pdf(i+1, u, v);
            }
            allProbs.push(probs);
            binned.push({x: i+1, y: probs});
            probs = 0.0;
        }
        var xDistScale = d3.scaleLinear()
            .domain([d3.min(allVals), d3.max(allVals)])
            .range([margin.left, getWidth()])
            ;
        var yDistScale = d3.scaleLinear()
            .domain([d3.min(allProbs), d3.max(allProbs)])
            .range([getHeight(), 0])
            ;

        var line = d3.line()
            .curve(d3.curveCatmullRom.alpha(0.5))
            .x(function(d) { return xDistScale(d.x); })
            .y(function(d) { return yDistScale(d.y); })
            ;

        var svgLines = svg.selectAll('aline')
            .data([binned])
            .enter()
            .append('g')
            .attr('transform', function(d) { 
                return 'translate(0,0)'; 
            })
            ;

        svgLines.append('path')
            .attr('d', function(d) { return line(d); })
            .style('stroke', '#BB0000')
            .style('stroke-width', 3)
            .style('stroke-dasharray', '5,5')
            .style('fill', 'none');

        console.log(allVals);
        console.log(binned);

        console.log(u);
        console.log(v);
    };

    var drawDistribution = function() {

        var bs = bins.map(function(b) { return b.length; });
        var tot = bs.reduce(function(a, b) { return a + b; });
        var dbins = [];
        var minlen = -1;

        for (var i = 0; i < bins.length; i++) {
            if (minlen === -1 || bins[i].length < minlen)
                minlen = bins[i].length;

            dbins.push({
                x0: bins[i].x0,
                x1: bins[i].x1,
                length: bins[i].length
            });
        }

        var line = d3.line()
            .curve(d3.curveCatmullRom.alpha(0.5))
            //.curve(d3.curveCatmullRom)
            //.x(function(d) { return xScale(d.x); })
            //.x(function(d) { console.log(xHistoScale((d.x0 + d.x1)/2)); return xHistoScale((d.x0 + d.x1) / 2); })
            //.x(function(d) { console.log(xHistoScale((d.x0 + d.x1)/2)); return xHistoScale((d.x0 + d.x1) / 2); })
            //.x(function(d) { return xScale((d.x0 + d.x1) / 2); })
            .x(function(d) { return xScale(d.x1) + (xScale.bandwidth() / 2); })
            //.x(function(d) { return xHistoScale((d.x0 + d.x1) / 2); })
            //.y(function(d) { return yScale(pdf(d.y, u, v)); })
            //.y(function(d) { return yScale(pdf(d.y, u, v, tot)); })
            //.y(function(d) { return yScale(d.y); })
            //.y(function(d) { console.log(yScale(d.length / tot)); return yScale(d.length); })
            //.y(function(d) { return yScale(d.length / tot) - (yScale(minlen / tot) - getHeight()); })
            .y(function(d) { return yScale(d.length / tot); })
            ;


        var svgLines = svg.selectAll('aline')
            .data([dbins])
            .enter()
            .append('g')
            .attr('transform', function(d) { 
                return 'translate(0,0)'; 
            })
            ;

        svgLines.append('path')
            .attr('d', function(d) { return line(d); })
            .style('stroke', '#BB0000')
            .style('stroke-width', 3)
            .style('stroke-dasharray', '5,5')
            .style('fill', 'none');


    };

    var drawText = function() {

        if (svgLabel) {

            svg.append('text')
                .attr('transform', 'translate(-' + margin.left + ',-' + margin.top + ')')
                .attr('x', 10)
                .attr('y', 15)
                .style('font-family', 'sans-serif')
                .style('font-size', '15px')
                .style('font-weight', 'bold')
                .text(svgLabel);
        }

        if (title) {

            var ma = margin.left + margin.right;
            svg.append('text')
                //.attr('transform', 'translate(-' + margin.left  + ',-' + margin.top + ')')
                .attr('transform', 'translate(' + 0  + ',-' + margin.top + ')')
                //.attr('x', getWidth() / 2)
                .attr('x', getWidth() / 2)
                .attr('y', margin.top / 2)
                .attr('text-anchor', 'middle')
                .style('font-family', 'sans-serif')
                .style('font-size', '17px')
                .style('font-weight', 'normal')
                .text(title);
        }


    };

    /** public **/

    exports.draw = function() {

        svg = d3.select('body')
            .append('svg')
            .attr('height', height)
            .attr('width', width)
            .append('g')
            .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
            ;

        if (textures)
            for (var i = 0; i < textures.length; i++)
                svg.call(textures[i]);

        grouped = checkGrouped();

        makeScales();

        if (grouped) {
            groups = returnKeyUniques('group');
        }

        makeAxes();
        drawBars();
        //drawDistribution();
        drawText();

        if (distribution)
            drawdist();
    };

    /** setters/getters **/

    exports.data = function(_) {
        if (!arguments.length) return data;
        data = _;
        return exports;
    };

    exports.width = function(_) {
        if (!arguments.length) return width;
        width = +_;
        return exports;
    };

    exports.height = function(_) {
        if (!arguments.length) return height;
        height = +_;
        return exports;
    };

    exports.barStroke = function(_) {
        if (!arguments.length) return barStroke;
        barStroke = +_;
        return exports;
    };

    exports.barColor = function(_) {
        if (!arguments.length) return barColor;
        barColor = _;
        return exports;
    };

    exports.barWidth = function(_) {
        if (!arguments.length) return barWidth;
        barWidth = +_;
        return exports;
    };

    exports.outerTicks = function(_) {
        if (!arguments.length) return outerTicks;
        outerTicks = _;
        return exports;
    };

    exports.grouped = function(_) {
        if (!arguments.length) return grouped;
        grouped = _;
        return exports;
    };

    exports.numBins = function(_) {
        if (!arguments.length) return numBins;
        numBins = +_;
        return exports;
    };

    exports.asHistogram = function(_) {
        if (!arguments.length) return asHistogram;
        asHistogram = _;
        return exports;
    };

    exports.customBins = function(_) {
        if (!arguments.length) return customBins;
        customBins = _;
        return exports;
    };

    exports.dropLastBin = function(_) {
        if (!arguments.length) return dropLastBin;
        dropLastBin = _;
        return exports;
    };

    exports.binPercent = function(_) {
        if (!arguments.length) return binPercent;
        binPercent = _;
        return exports;
    };

    exports.yAxisPad = function(_) {
        if (!arguments.length) return yAxisPad;
        yAxisPad = +_;
        return exports;
    };

    exports.innerPadding = function(_) {
        if (!arguments.length) return innerPadding;
        innerPadding = +_;
        return exports;
    };

    exports.fontSize = function(_) {
        if (!arguments.length) return fontSize;
        fontSize = _;
        return exports;
    };

    exports.xText = function(_) {
        if (!arguments.length) return xText;
        xText = _;
        return exports;
    };

    exports.yFormat = function(_) {
        if (!arguments.length) return yFormat;
        yFormat = _;
        return exports;
    };

    exports.yText = function(_) {
        if (!arguments.length) return yText;
        yText = _;
        return exports;
    };

    exports.title = function(_) {
        if (!arguments.length) return title;
        title = _;
        return exports;
    };

    exports.svgLabel = function(_) {
        if (!arguments.length) return svgLabel;
        svgLabel = _;
        return exports;
    };

    exports.groupColors = function(_) {
        if (!arguments.length) return groupColors;
        groupColors = _;
        return exports;
    };

    exports.textures = function(_) {
        if (!arguments.length) return textures;
        textures = _;
        return exports;
    };

    exports.distribution = function(_) {
        if (!arguments.length) return distribution;
        distribution = _;
        return exports;
    };

    exports.yTickValues = function(_) {
        if (!arguments.length) return yTickValues;
        yTickValues = _;
        return exports;
    };

    exports.yDomain = function(_) {
        if (!arguments.length) return yDomain;
        yDomain = _;
        return exports;
    };

    return exports;
};

