/**
 * file: bundle.js
 * desc: d3js 4.0 implementation of hierarchical edge bundling.
 * vers: 0.2.0
 * auth: TR
 */

// Don't fucking forget the id variables have to be strings or this thing shits
// the bed.
/*
 * The graph data structure necessary for this viz is an object containing two
 * lists, 'nodes' and 'edges'. Each node object can have the following fields:
 *  node {
 *      id:         [required] node ID 
 *      depth:      [required] int used to represent depth in the hierarchy
 *      colorValue: [optional] int value used to generate a range of colors
 *      label:      [optional] text label to append to the node
 *      radius:     [optional] size of the node
 *      color:      [optional] node color
 * }
 *
 * edge {
 *      source: [required] ID of the source node
 *      target: [required] ID of the source node
 *      width:  [optional] width of the edge in pixels
 * }
 *
 */
var bundle = function() {

    var exports = {},
        svg = null,
        svgLabel = '',
        // SVG diameter (width and height)
        diameter = 960,
        // Radius used to generate the circular bundle graph (d / 2)
        radius = diameter / 2,
        // Inner radius of the bundle graph
        innerRadius = radius - 120,
        // Separation distance between nodes of the same group
        separation = 0.5,
        // Root node of a d3 generated hierarchy
        rootNode = null,
        d3Nodes = null,
        d3Edges = null,



        // Graph data struct which should contain a key for nodes and edges
        graph = null
            ;

    /** private **/


    /**
     * Because the d3js stratify() function is fucked when it comes to
     * hierarchies and clusters.
     *
     */
    var buildHierarchy = function(nodes) {

        var map = {};

        function find(id, data) {

            var node = map[id];

            if (!node) {

                node = map[id] = data || {id: id, children: []};

                if (node.children === undefined)
                    node.children = [];

                if (id.length) {

                    node.parent = find(node.parent);
                    node.parent.children.push(node);
                }

            }

            return node;
        }

        nodes.forEach(function(d) {
            find(d.id, d);
        });

        return map[''];
    };

    /**
     * Rebuilds the user provided edge list by replacing source and target with
     * node objects generated by d3.cluster().
     *
     */
    var buildEdges = function(nodes, edges) {

		var map = {};

		nodes.forEach(function(d) {
			map[d.data.id] = d;
		});

		edges.forEach(function(d) {
			d.source = map[d.source];
			d.target = map[d.target];
		});

		return edges;
    };

    var drawNodes = function() {

        var nodes = rootNode.descendants();

        var d3Nodes = svg.append('g')
            .selectAll('.node')
            .data(nodes.filter(function(n) { return !n.children; }))
            .enter()

            /*
            .append('circle')
            .attr('r', 7)
            .attr('transform', function(d) { 

                return 'rotate(' + (d.x - 90) + ')' + 
                    'translate(' + (d.y + 8) + ',0)' + 
                    (d.x < 180 ? '' : 'rotate(180)'); 
            })
            .style('stroke', '#000')
            .style('stroke-width', 1)
            .style('fill', function(d) {
                console.log(d);
                console.log(d.data);
                return d.data.color ? d.data.color : '#000';
            })
            */

            .append('text')
            //.attr('class', 'node')
            .attr('fill', '#000000')
            .attr('dy', '.31em')
            .attr('transform', function(d) { 

                return 'rotate(' + (d.x - 90) + ')' + 
                    'translate(' + (d.y + 8) + ',0)' + 
                    (d.x < 180 ? '' : 'rotate(180)'); 
            })
            .style('text-anchor', function(d) { 
                return d.x < 180 ? 'start' : 'end'; 
            })
            .style('font-family', 'sans-serif')
            .style('font-size', '12px')
            .style('text-decoration', function(d) {

                return d.data.textDecoration ? d.data.textDecoration : 'none';
            })
            .text(function(d) { return d.data.label; })
            ;
    };

    var drawEdges = function() {

        var edges = buildEdges(rootNode.descendants(), graph.edges);
        var line = d3.radialLine()
            .radius(function(d) { return d.y; })
            .angle(function(d) { return d.x / 180 * Math.PI; })
            .curve(d3.curveBundle.beta(0.55))
            ;

        link = svg.append('g')
            .selectAll('.link')
            .data(edges)
            .enter()
            .append('path')
            .attr('class', 'link')
            .attr('d', function(d) { 
                console.log(d);
                return line(d.source.path(d.target)); 
            })
			.attr('stroke', function(d) {
                if (d.color == 'steelblue')
                    //return '#feb24c';
                    return 'steelblue';
                else
                    return '#f03b20';
				return d.color ? d.color : 'steelblue';
			})
			.attr('stroke-opacity', 0.6)
			.attr('stroke-width', 
				function(d) { return d.width ? d.width : 2;
			})
			.attr('fill', 'none')
			;
    };

    var drawGroupLines = function() {

        var nodes = rootNode.descendants().filter(function(n) { 
            return !n.children; 
        });
        var edges = [[]];

        // Groups the coordinates of all related nodes together
        for (var i = 0; i < nodes.length - 1; i++) {
            var a = nodes[i];
            var b = nodes[i + 1];

            if (a.parent == b.parent) { 
                edges[edges.length - 1].push({
                    start: a.x, 
                    end: b.x, 
                    radius: a.y,
                    tag: a.data.id + '-group'
                });
                    
                //edges.push({start: a.x, end: b.x, radius: a.y});
            } else {
                //edges.push([{start: a.x, end: b.x, radius: a.y}]);
                edges.push([]);
            }
        }

        edges = edges.filter(function(a) { return a.length !== 0; });

        console.log(edges);
        edges.forEach(function(d, i) {

            var min = d3.min(d, function(e) { return d3.min([e.start, e.end]); });
            var max = d3.max(d, function(e) { return d3.max([e.start, e.end]); });

            edges[i] =  {
                start: min, 
                end: max, 
                radius: d[0].radius,
                tag: d[0].tag
            };
        });

        var arc = d3.arc()
            .innerRadius(radius - 5)
            .outerRadius(radius)
            .innerRadius(function(d) { return d.radius + 5; })
            .outerRadius(function(d) { return d.radius + 10; })
            .startAngle(function (d) { return d.start / 180 * Math.PI; })
            //.endAngle(function (d) { return d.y ; })
            .endAngle(function (d) { return d.end / 180 * Math.PI; })
            ;

        var line = d3.radialLine()
            .radius(function(d) { return d.y; })
            .angle(function(d) { return d.x / 180 * Math.PI; })
            //.curve(d3.curveBundle.beta(0.0))
            //.curve(d3.curveBasis.alpha(0))
            .curve(d3.curveCatmullRom.alpha(1))
            ;

        link = svg.append('g')
            .selectAll('.link')
            .data(edges)
            .enter()
            .append('path')
            .attr('class', 'link')
            .attr('id', function(d) { return d.tag; })
            //.attr('d', function(d) { return line(d.source.path(d.target)); })
            //.attr('d', function(d) { return line([d.source, d.target]); })
            //.attr('d', function(d) { return arc([d.source.x, d.target.x]); })
            .attr('d', function(d) { return arc(d); })
			.style('stroke', function(d) {
				return d.color ? d.color : '#555';
			})
			.style('fill', function(d) {
				return d.color ? d.color : '#555';
			})
			.attr('stroke-opacity', 1)
			.attr('stroke-width', 
				function(d) { return d.width ? d.width : 2;
			})
			;

            /*
        var texts = svg.selectAll('linkTexts')
            .data(edges)
            .enter()
            .append('text')
            .attr('dy', -5)
            .style('text-anchor', 'middle')
            .append('textPath')
            .attr('xlink:href', function(d) { return '#' + d.tag; })
            //.attr('startOffset', '20%')
            .text('genes and shit')
            ;
            */
    };

    var drawCircumference = function() {

        var arc = d3.arc()
            .innerRadius(innerRadius + 7)
            .outerRadius(innerRadius + 7)
            .startAngle(function (d) { return 0; })
            .endAngle(function (d) { return 360; })
            ;

        link = svg.append('g')
            .append('path')
            .attr('class', 'link')
            //.attr('d', function(d) { return line(d.source.path(d.target)); })
            //.attr('d', function(d) { return line([d.source, d.target]); })
            //.attr('d', function(d) { return arc([d.source.x, d.target.x]); })
            .attr('d', function(d) { return arc(); })
			.style('stroke', function(d) {
				//return d.color ? d.color : '#555';
				return '#555';
			})
			.style('fill', function(d) {
				//return d.color ? d.color : '#555';
				return '#555';
			})
			.attr('stroke-opacity', 1)
			.attr('stroke-width', 
				function(d) { return 2;//d.width ? d.width : 2;
			})
			;
    };

    /** public **/

    exports.draw = function() {

        // Radius used to generate the circular bundle graph (d / 2)
        radius = diameter / 2;
        // Inner radius of the bundle graph
        innerRadius = radius - 120;

        svg = d3.select('body')
            .append('svg')
            .attr('height', diameter)
            .attr('width', diameter)
            .append('g')
            .attr('transform', 'translate(' + radius + ',' + radius + ')')
            ;

        var cluster = d3.cluster()
            .size([360, innerRadius])
            .separation(function(a, b) {
                return a.parent == b.parent ? separation: 2;
            });

        graph.nodes = buildHierarchy(graph.nodes);
        rootNode = d3.hierarchy(graph.nodes);

        cluster(rootNode);
        drawNodes();
        drawEdges();
        drawGroupLines();
        drawCircumference();
    };

    /**
     * Setters and getters.
     */

    exports.graph = function(_) {
        if (!arguments.length) return graph;
        graph = _;
        return exports;
    };

    exports.innerRadius = function(_) {
        if (!arguments.length) return innerRadius;
        innerRadius = +_;
        return exports;
    };

    exports.height = function(_) {
        if (!arguments.length) return height;
        height = +_;
        return exports;
    };

    exports.diameter = function(_) {
        if (!arguments.length) return diameter;
        diameter = +_;
        return exports;
    };

    exports.radius = function(_) {
        if (!arguments.length) return radius;
        radius = +_;
        return exports;
    };

    exports.charge = function(_) {
        if (!arguments.length) return charge;
        charge = +_;
        return exports;
    };

    exports.distance = function(_) {
        if (!arguments.length) return distance;
        distance = +_;
        return exports;
    };

    exports.fixed = function(_) {
        if (!arguments.length) return fixed;
        fixed = _;
        return exports;
    };

    exports.layerSize = function(_) {
        if (!arguments.length) return layerSize;
        layerSize = +_;
        return exports;
    };

    exports.verticalSpacing = function(_) {
        if (!arguments.length) return verticalSpacing;
        verticalSpacing = +_;
        return exports;
    };

    exports.nodeColor = function(_) {
        if (!arguments.length) return nodeColor;
        nodeColor = _;
        return exports;
    };

    exports.nodeOpacity = function(_) {
        if (!arguments.length) return nodeOpacity;
        nodeOpacity = +_;
        return exports;
    };

    exports.scaleFxn = function(_) {
        if (!arguments.length) return scaleFxn;
        scaleFxn = _;
        return exports;
    };

    exports.useColorRange = function(_) {
        if (!arguments.length) return useColorRange;
        useColorRange = _;
        return exports;
    };

    exports.useSizeRange = function(_) {
        if (!arguments.length) return useSizeRange;
        useSizeRange = _;
        return exports;
    };

    exports.gradient = function(_) {
        if (!arguments.length) return gradient;
        gradient = _;
        return exports;
    };

    exports.useDarkStroke = function(_) {
        if (!arguments.length) return useDarkStroke;
        useDarkStroke = _;
        return exports;
    };

    exports.useShadow = function(_) {
        if (!arguments.length) return useShadow;
        useShadow = _;
        return exports;
    };

    exports.nodeStroke = function(_) {
        if (!arguments.length) return nodeStroke;
        nodeStroke = _;
        return exports;
    };

    exports.nodeStrokeWidth = function(_) {
        if (!arguments.length) return nodeStrokeWidth;
        nodeStrokeWidth = +_;
        return exports;
    };

    exports.prettifyNodes = function(_) {
        if (!arguments.length) return prettifyNodes;
        prettifyNodes = _;
        return exports;
    };

    exports.edgeCurve = function(_) {
        if (!arguments.length) return edgeCurve;
        edgeCurve = _;
        return exports;
    };

    exports.edgeColor = function(_) {
        if (!arguments.length) return edgeColor;
        edgeColor = _;
        return exports;
    };

    exports.edgeOpacity = function(_) {
        if (!arguments.length) return edgeOpacity;
        edgeOpacity = +_;
        return exports;
    };

    exports.edgeStroke = function(_) {
        if (!arguments.length) return edgeStroke;
        edgeStroke = _;
        return exports;
    };

    exports.edgeWidth = function(_) {
        if (!arguments.length) return edgeWidth;
        edgeWidth = +_;
        return exports;
    };

    exports.tx = function(_) {
        if (!arguments.length) return tx;
        tx = +_;
        return exports;
    };

    exports.ty = function(_) {
        if (!arguments.length) return ty;
        ty = +_;
        return exports;
    };

    exports.font = function(_) {
        if (!arguments.length) return font;
        font = _;
        return exports;
    };

    exports.fontColor = function(_) {
        if (!arguments.length) return fontColor;
        fontColor = _;
        return exports;
    };

    exports.fontSize = function(_) {
        if (!arguments.length) return fontSize;
        fontSize = _;
        return exports;
    };

    exports.fontWeight = function(_) {
        if (!arguments.length) return fontWeight;
        fontWeight = _;
        return exports;
    };

    exports.svgLabel = function(_) {
        if (!arguments.length) return svgLabel;
        svgLabel = _;
        return exports;
    };

    exports.textures = function(_) {
        if (!arguments.length) return textures;
        textures = _;
        return exports;
    };

    return exports;
};

